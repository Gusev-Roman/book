description: Структуры данных

# Возможности (capabilities)

Каждая возможность предоставляет функцию в форме интерфейса, наряду с реализацией по умолчанию, которую можно запросить, и обработчиком хранилища, по крайней мере, для этой реализации по умолчанию. Обработчик хранилища может поддерживать и другие реализации, но это зависит от разработчика возможностей, поэтому стоит ознакомиться с его документацией, прежде чем пытаться использовать хранилище по умолчанию с реализациями, отличными от стандартных.

Forge добавляет поддержку возможностей для TileEntities, Entities, ItemStacks, Worlds и Chunks, которые могут быть представлены либо путем присоединения их через событие, либо путем переопределения методов возможностей в ваших собственных реализациях объектов. Это будет объяснено более подробно в следующих разделах.

# Возможности, предоставляемые Forge

Forge определяет три типа возможностей: `IItemHandler`, `IFluidHandler` и `IEnergyStorage`.
* `IItemHandler` предоставляет интерфейс для обработки слотов инвентаря. Его можно применить к TileEntities (сундуки, механизмы и т. д.), Entities (дополнительные инвентари для игроков / сумки мобов / существ) или ItemStacks (переносные рюкзаки и т. д.). Этот интерфейс пришел на смену IInventory и ISidedInventory предыдущих версий.
* `IFluidHandler` предоставляет интерфейс для работы с запасами жидкости. Его также можно применить к объектам TileEntities или ItemStacks. Мобильные сущности возможностями хранения жидкости не обладают! Данный интерфейс заменяет старую систему `IFluidHandler` более последовательной и удобной для автоматизации. 
* `IEnergyStorage` предоставляет интерфейс для работы с энергетическими контейнерами. Его можно применить к TileEntities (механизмы), Entities (роботы, транспорт) или ItemStacks (аккумуляторы). Он основан на API RedstoneFlux от TeamCoFH.

# Использование существующих возможностей

Как уже говорилось, TileEntities, Entities и ItemStacks реализуют функцию поставщика возможностей через интерфейс `ICapabilityProvider`. Этот интерфейс добавляет два метода, `hasCapability` и `getCapability`, которые можно использовать для запроса возможностей, представленных в объектах.
Чтобы получить возможность, вам нужно будет сослаться на нее по ее уникальному экземпляру. В случае обработчика элементов эта возможность в основном хранится в `CapabilityItemHandler.ITEM_HANDLER_CAPABILITY`, но можно получить ссылки на другие экземпляры с помощью аннотации `@CapabilityInject`.

```java
@CapabilityInject(IItemHandler.class)
static Capability<IItemHandler> ITEM_HANDLER_CAPABILITY = null;
```

Эта аннотация может применяться к полям и к методам. При применении к полю он назначит экземпляр возможности (тот же самый назначается всем полям) после регистрации возможности и оставит существующее значение `(null)`, если возможность никогда не была зарегистрирована. Поскольку доступ к локальным статическим полям осуществляется быстро, рекомендуется сохранить собственную локальную копию ссылки для объектов, которые работают с возможностями. Эту аннотацию также можно использовать в методе, чтобы получать уведомления при регистрации возможности, чтобы определенные функции можно было включить условно.
Методы `hasCapability` и `getCapability` имеют второй параметр, тип `EnumFacing`, который может быть использован в запросе, специфическом для конкретной стороны. Если он передан как `null`, можно предположить, что запрос исходит либо из блока, либо из какого-то места, где сторона не имеет значения, например, из другого измерения. В этом случае вместо этого будет запрошен общий экземпляр возможности, который не зависит от стороны. Тип возвращаемого значения `getCapability` будет соответствовать типу, объявленному в возможности, переданной методу. Для возможности обработчика предметов это действительно так `IItemHandler`.

# Раскрытие возможностей (Exposing a Capability)

Чтобы раскрыть возможность, вам сначала понадобится экземпляр базового типа возможности. Обратите внимание, что вам следует назначить отдельный экземпляр для каждого объекта, который сохраняет возможность, поскольку возможность, скорее всего, будет привязана к содержащему объекту.

Есть два способа получить такой экземпляр: через сам `Capability` или явно создав его реализацию. Первый метод предназначен для использования реализации по умолчанию, если эти значения по умолчанию вам полезны. В случае возможности обработчика предметов реализация по умолчанию будет предоставлять инвентарь с одним слотом, что, скорее всего, не то, что вам нужно.

Второй метод может использоваться для предоставления пользовательских реализаций. В случае реализации `IItemHandler` по умолчанию используется класс `ItemStackHandler`, который имеет необязательный аргумент в конструкторе, чтобы указать количество слотов. Однако следует избегать полагаться на существование этих реализаций по умолчанию, так как целью системы возможностей является предотвращение ошибок загрузки в контекстах, где возможность отсутствует, поэтому создание экземпляра должно быть защищено проверочным тестированием, если возможность была зарегистрирована. (см. примечания `@CapabilityInject` к предыдущему разделу).

Если у вас есть собственный экземпляр интерфейса возможностей, вы захотите уведомить пользователей системы возможностей, что вы предоставляете эту возможность. Это делается путем переопределения метода `hasCapability` и сравнения экземпляра с возможностями, которые вы предоставляете. Если на вашем компьютере разные слоты в зависимости от того, с какой стороны выполняется запрос, вы можете проверить это с помощью facingпараметра. Для Entities и ItemStacks этот параметр можно игнорировать, но все же возможно иметь сторону в качестве контекста, например, различные слоты для брони на игроке (верхняя сторона => слот для головы?) Или окружающие блоки в инвентаре ( запад => слот слева?). Не забудьте обратиться к одноименному методу суперкласса, иначе прикрепленные возможности перестанут работать.

```java
@Override
public boolean hasCapability(Capability<?> capability, EnumFacing facing) {
  if (capability == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) {
    return true;
  }
  return super.hasCapability(capability, facing);
}
```

Аналогично предоставьте ссылку на интерфейс для вашего экземпляра возможности. Опять же, не забудьте обратиться к суперклассу.

```java
@Override
public <T> T getCapability(Capability<T> capability, EnumFacing facing) {
  if (capability == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) {
    return (T) inventory;
  }
  return super.getCapability(capability, facing);
}
```

Настоятельно рекомендуется использовать прямые проверки в коде для проверки возможностей вместо попыток полагаться на карты или другие структуры данных, поскольку тесты возможностей могут выполняться многими объектами каждый тик, и они должны выполняться как можно быстрее, чтобы не замедлять игры.

# Присоединение возможностей

Как уже упоминалось, прикрепление возможностей к сущностям и стекам элементов можно выполнить с помощью `AttachCapabilitiesEvent`. Одно и то же событие используется для всех объектов, которые могут предоставлять возможности. `AttachCapabilitiesEvent` имеет 5 допустимых универсальных типов, обеспечивающих следующие события:

* `AttachCapabilitiesEvent<Entity>`: Применяется только для сущностей.
* `AttachCapabilitiesEvent<TileEntity>`: Применяется только для TileEntity.
* `AttachCapabilitiesEvent<ItemStack>`: Применяется только для ItemStack.
* `AttachCapabilitiesEvent<World>`: Применяется только для миров.
* `AttachCapabilitiesEvent<Chunk>`: Применяется только для чанков.

Универсальный тип не может быть более конкретным, чем приведенные выше типы. Например: если вы хотите присоединить возможности к `EntityPlayer`, вы должны подписаться на `AttachCapabilitiesEvent<Entity>`, а затем определить, что предоставленный объект является `EntityPlayer` перед присоединением возможности.

Во всех случаях у события есть метод `addCapability`, который можно использовать для прикрепления возможностей к целевому объекту. Вместо добавления самих возможностей в список вы добавляете поставщиков возможностей, которые могут возвращать возможности только с определенных сторон. В то время как поставщику необходимо только реализовать `ICapabilityProvider`, если возможность должна постоянно хранить данные, можно реализовать, `ICapabilitySerializable<T extends NBTBase>` которая, помимо возврата возможностей, позволит предоставлять функции сохранения / загрузки NBT.

Для получения информации о том, как реализовать `ICapabilityProvider`, обратитесь к разделу «Раскрытие возможностей».

# Создание пользовательских возможностей

В общих чертах, возможность объявляется и регистрируется посредством одного вызова метода `CapabilityManager.INSTANCE.register()`. Одна из возможностей - определить статический метод `register()` внутри выделенного класса для возможности, но это не требуется для системы возможностей. В целях этой документации мы будем описывать каждую часть как отдельный именованный класс, хотя анонимные классы - тоже вариант.
```java
CapabilityManager.INSTANCE.register(capability interface class, storage, default implementation factory);
```
Первым параметром этого метода является тип, описывающий функциональную возможность. В нашем примере это будет `IExampleCapability.class`.

Второй параметр - это экземпляр класса, который реализует `Capability.IStorage<T>`, где T - тот же класс, который мы указали в первом параметре. Этот класс хранилища поможет управлять сохранением и загрузкой для реализации по умолчанию, а также может, при желании, поддерживать другие реализации.
  
```java
private static class Storage
    implements Capability.IStorage<IExampleCapability> {

  @Override
  public NBTBase writeNBT(Capability<IExampleCapability> capability, IExampleCapability instance, EnumFacing side) {
    // return an NBT tag
  }

  @Override
  public void readNBT(Capability<IExampleCapability> capability, IExampleCapability instance, EnumFacing side, NBTBase nbt) {
    // load from the NBT tag
  }
}
```

Последний параметр - это вызываемая фабрика, которая вернет новые экземпляры реализации по умолчанию.
```java
private static class Factory implements Callable<IExampleCapability> {

  @Override
  public IExampleCapability call() throws Exception {
    return new Implementation();
  }
}
```
Наконец, нам понадобится сама реализация по умолчанию, чтобы иметь возможность создать ее экземпляр на фабрике. Создание этого класса зависит от вас, но он должен, по крайней мере, предоставить базовый каркас, который люди могут использовать для тестирования возможностей, если это не является полностью пригодной для использования реализацией.

# Сохранение возможностей Chunk и TileEntity

В отличие от Worlds, Entities и ItemStacks, Chunks и TileEntities записываются на диск только тогда, когда они помечены как "грязные". Поэтому реализация возможности с постоянным состоянием для Chunk или TileEntity должна гарантировать, что всякий раз, когда его состояние изменяется, его владелец помечается как "грязный".

ItemStackHandler, обычно используемый для инвентаризации в TileEntities, имеет переопределяемый метод, void onContentsChanged(int slot) предназначенный для пометки TileEntity как "грязного".
```java
public class MyTileEntity extends TileEntity {

  private final IItemHandler inventory = new ItemStackHandler(...) {
    @Override
    protected void onContentsChanged(int slot) {
      super.onContentsChanged(slot);
      markDirty();
    }
  }

  ...
}
```

# Синхронизация данных с клиентами

По умолчанию данные о возможностях не отправляются клиентам. Чтобы изменить это, моды должны управлять своим собственным кодом синхронизации с помощью пакетов.

Есть три различных ситуации, в которых вы можете захотеть отправить пакеты синхронизации, все они необязательны:

* Когда сущность появляется в мире или размещается блок, вы можете поделиться с клиентами значениями, назначенными при инициализации.
* При изменении сохраненных данных вы можете уведомить некоторых или всех наблюдающих клиентов.
* Когда новый клиент начинает просматривать объект или блок, вы можете уведомить его о существующих данных.

Обратитесь к странице «Сеть» для получения дополнительной информации о реализации сетевых пакетов.

# Сохранение при смерти игроков

По умолчанию данные о возможностях не сохраняются после смерти. Чтобы изменить это, данные должны быть скопированы вручную, когда сущность игрока клонируется во время процесса возрождения.

Это можно сделать, обработав событие `PlayerEvent.Clone`, прочитав данные из исходной сущности и назначив их новой сущности. В этом случае можно использовать поле `wasDead`, чтобы различать возрождение после смерти и возвращение из другого измерения. Это важно, потому что данные уже будут существовать при возврате из другого измерения, поэтому следует позаботиться о том, чтобы не дублировать значения в этом случае.
